import ExcelJS from 'exceljs';
import type { SkillEvidence, EvidenceSchema, EvidenceColumnDef, DataSourceContribution, SkillParameter } from '../skills/types.js';

interface WorkbookOptions {
  agentName?: string;
  skillId?: string;
  runDate: string;
  narrative: string;
  workspaceName: string;
  evidence?: SkillEvidence;
  evidenceSchema?: EvidenceSchema;
  skillEvidence?: Record<string, { evidence: SkillEvidence; schema?: EvidenceSchema; displayName?: string }>;
}

const HEADER_FILL: ExcelJS.Fill = {
  type: 'pattern',
  pattern: 'solid',
  fgColor: { argb: 'FF2B5797' },
};

const HEADER_FONT: Partial<ExcelJS.Font> = {
  bold: true,
  color: { argb: 'FFFFFFFF' },
  size: 11,
};

const PARAM_FILL: ExcelJS.Fill = {
  type: 'pattern',
  pattern: 'solid',
  fgColor: { argb: 'FFFFFF00' },
};

const SEVERITY_FILLS: Record<string, ExcelJS.Fill> = {
  critical: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFCE4EC' } },
  warning: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFDE7' } },
  healthy: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE8F5E9' } },
};

const TITLE_FONT: Partial<ExcelJS.Font> = { bold: true, size: 14 };
const SECTION_FONT: Partial<ExcelJS.Font> = { bold: true, size: 12 };
const LABEL_FONT: Partial<ExcelJS.Font> = { bold: true, size: 11 };

export async function generateWorkbook(options: WorkbookOptions): Promise<Buffer> {
  const wb = new ExcelJS.Workbook();
  wb.creator = 'Pandora GTM Intelligence';
  wb.created = new Date();

  const summary = wb.addWorksheet('Summary & Methodology');
  let currentRow = 1;

  currentRow = addMetadataSection(summary, currentRow, {
    title: options.agentName || options.skillId || 'Skill Report',
    runDate: options.runDate,
    workspace: options.workspaceName,
  });

  currentRow = addNarrativeSection(summary, currentRow, options.narrative);

  const allEvidence = options.skillEvidence
    ? Object.values(options.skillEvidence).map(s => s.evidence)
    : options.evidence ? [options.evidence] : [];

  const mergedSources = mergeDataSources(allEvidence);
  currentRow = addDataSourcesSection(summary, currentRow, mergedSources);

  const mergedParams = mergeParameters(allEvidence);
  currentRow = addParametersSection(summary, currentRow, mergedParams);

  addKeyMetricsSection(summary, currentRow, allEvidence);

  summary.getColumn(1).width = 30;
  summary.getColumn(2).width = 40;
  summary.getColumn(3).width = 20;

  if (options.skillEvidence) {
    for (const [key, { evidence, schema, displayName }] of Object.entries(options.skillEvidence)) {
      if (evidence.evaluated_records?.length > 0) {
        addDataTab(wb, {
          tabName: sanitizeTabName(displayName || key),
          schema: schema || null,
          evidence,
        });
      }
    }
  } else if (options.evidence && options.evidence.evaluated_records?.length > 0) {
    addDataTab(wb, {
      tabName: sanitizeTabName(options.skillId || 'Data'),
      schema: options.evidenceSchema || null,
      evidence: options.evidence,
    });
  }

  const buffer = await wb.xlsx.writeBuffer();
  return Buffer.from(buffer);
}

function sanitizeTabName(name: string): string {
  return name.replace(/[\\/*?[\]:]/g, '-').slice(0, 31);
}

function addMetadataSection(
  ws: ExcelJS.Worksheet,
  startRow: number,
  meta: { title: string; runDate: string; workspace: string }
): number {
  let row = startRow;

  const titleCell = ws.getCell(row, 1);
  titleCell.value = meta.title;
  titleCell.font = TITLE_FONT;
  row += 2;

  ws.getCell(row, 1).value = 'Workspace:';
  ws.getCell(row, 1).font = LABEL_FONT;
  ws.getCell(row, 2).value = meta.workspace;
  row++;

  ws.getCell(row, 1).value = 'Run Date:';
  ws.getCell(row, 1).font = LABEL_FONT;
  const runDate = new Date(meta.runDate);
  ws.getCell(row, 2).value = isNaN(runDate.getTime())
    ? meta.runDate
    : runDate.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' });
  row++;

  ws.getCell(row, 1).value = 'Generated By:';
  ws.getCell(row, 1).font = LABEL_FONT;
  ws.getCell(row, 2).value = 'Pandora GTM Intelligence';
  row += 2;

  return row;
}

function addNarrativeSection(ws: ExcelJS.Worksheet, startRow: number, narrative: string): number {
  let row = startRow;

  ws.getCell(row, 1).value = 'Analysis Narrative';
  ws.getCell(row, 1).font = SECTION_FONT;
  row++;

  if (narrative) {
    const lines = narrative.split('\n');
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) { row++; continue; }
      const cleaned = trimmed.replace(/^#{1,3}\s*/, '').replace(/\*\*(.+?)\*\*/g, '$1');
      ws.getCell(row, 1).value = cleaned;
      ws.getCell(row, 1).alignment = { wrapText: true };
      row++;
    }
  }

  row += 1;
  return row;
}

function addDataSourcesSection(
  ws: ExcelJS.Worksheet,
  startRow: number,
  sources: DataSourceContribution[]
): number {
  let row = startRow;

  ws.getCell(row, 1).value = 'Data Sources';
  ws.getCell(row, 1).font = SECTION_FONT;
  row++;

  const headers = ['Source', 'Connected', 'Last Sync', 'Records'];
  headers.forEach((h, i) => {
    const cell = ws.getCell(row, i + 1);
    cell.value = h;
    cell.font = HEADER_FONT;
    cell.fill = HEADER_FILL;
  });
  row++;

  for (const ds of sources) {
    ws.getCell(row, 1).value = ds.source;
    ws.getCell(row, 2).value = ds.connected ? 'Yes' : 'No';
    ws.getCell(row, 3).value = ds.last_sync
      ? new Date(ds.last_sync).toLocaleDateString('en-US')
      : 'N/A';
    ws.getCell(row, 4).value = ds.records_available ?? 0;
    ws.getCell(row, 4).numFmt = '#,##0';

    if (!ds.connected) {
      for (let c = 1; c <= 4; c++) {
        ws.getCell(row, c).font = { italic: true, color: { argb: 'FF999999' } };
      }
    }
    row++;
  }

  row += 1;
  return row;
}

function addParametersSection(
  ws: ExcelJS.Worksheet,
  startRow: number,
  params: SkillParameter[]
): number {
  let row = startRow;

  ws.getCell(row, 1).value = 'Parameters & Thresholds';
  ws.getCell(row, 1).font = SECTION_FONT;
  row++;

  const headers = ['Parameter', 'Value', 'Configurable'];
  headers.forEach((h, i) => {
    const cell = ws.getCell(row, i + 1);
    cell.value = h;
    cell.font = HEADER_FONT;
    cell.fill = HEADER_FILL;
  });
  row++;

  for (const p of params) {
    ws.getCell(row, 1).value = p.display_name;
    const valCell = ws.getCell(row, 2);
    valCell.value = p.value;
    ws.getCell(row, 3).value = p.configurable ? 'Yes' : 'No';

    if (p.configurable) {
      valCell.fill = PARAM_FILL;
    }
    row++;
  }

  row += 1;
  return row;
}

function addKeyMetricsSection(
  ws: ExcelJS.Worksheet,
  startRow: number,
  allEvidence: SkillEvidence[]
): number {
  let row = startRow;

  ws.getCell(row, 1).value = 'Key Metrics';
  ws.getCell(row, 1).font = SECTION_FONT;
  row++;

  let totalRecords = 0;
  let totalClaims = 0;
  let criticalCount = 0;
  let warningCount = 0;

  for (const ev of allEvidence) {
    totalRecords += ev.evaluated_records.length;
    totalClaims += ev.claims.length;
    criticalCount += ev.evaluated_records.filter(r => r.severity === 'critical').length;
    warningCount += ev.evaluated_records.filter(r => r.severity === 'warning').length;
  }

  const metrics = [
    ['Total Records Evaluated', totalRecords],
    ['Total Claims', totalClaims],
    ['Critical Findings', criticalCount],
    ['Warning Findings', warningCount],
    ['Healthy Records', totalRecords - criticalCount - warningCount],
  ];

  for (const [label, value] of metrics) {
    ws.getCell(row, 1).value = label as string;
    ws.getCell(row, 1).font = LABEL_FONT;
    ws.getCell(row, 2).value = value as number;
    ws.getCell(row, 2).numFmt = '#,##0';
    row++;
  }

  row += 1;
  return row;
}

function addDataTab(
  wb: ExcelJS.Workbook,
  opts: { tabName: string; schema: EvidenceSchema | null; evidence: SkillEvidence }
): void {
  const ws = wb.addWorksheet(opts.tabName);
  const { schema, evidence } = opts;

  const baseCols: EvidenceColumnDef[] = [
    { key: 'entity_name', display: 'Name', format: 'text' },
    { key: 'owner_name', display: 'Owner', format: 'text' },
  ];

  const schemaCols = schema?.columns || [];
  const alreadyHasKeys = new Set(baseCols.map(c => c.key));
  const filteredSchema = schemaCols.filter(c => !alreadyHasKeys.has(c.key));

  const allCols: EvidenceColumnDef[] = [
    ...baseCols,
    ...filteredSchema,
    { key: 'severity', display: 'Severity', format: 'severity' },
  ];

  allCols.forEach((col, i) => {
    const cell = ws.getCell(1, i + 1);
    cell.value = col.display;
    cell.font = HEADER_FONT;
    cell.fill = HEADER_FILL;
  });

  evidence.evaluated_records.forEach((record, rowIdx) => {
    const row = rowIdx + 2;

    allCols.forEach((col, colIdx) => {
      const cell = ws.getCell(row, colIdx + 1);

      let value: any;
      if (col.key === 'entity_name') value = record.entity_name;
      else if (col.key === 'owner_name') value = record.owner_name;
      else if (col.key === 'severity') value = record.severity;
      else value = record.fields?.[col.key] ?? record.flags?.[col.key] ?? '';

      cell.value = value;

      switch (col.format) {
        case 'currency':
          if (typeof value === 'number') cell.numFmt = '$#,##0';
          break;
        case 'percentage':
          if (typeof value === 'number') cell.numFmt = '0.0%';
          break;
        case 'number':
          if (typeof value === 'number') cell.numFmt = '#,##0';
          break;
        case 'date':
          if (value && typeof value === 'string') {
            const d = new Date(value);
            if (!isNaN(d.getTime())) {
              cell.value = d;
              cell.numFmt = 'YYYY-MM-DD';
            }
          }
          break;
      }
    });

    const severityFill = SEVERITY_FILLS[record.severity] || SEVERITY_FILLS.healthy;
    allCols.forEach((_, colIdx) => {
      ws.getCell(row, colIdx + 1).fill = severityFill;
    });
  });

  ws.columns.forEach(col => { col!.width = 18; });

  const nameCol = ws.getColumn(1);
  if (nameCol) nameCol.width = 30;
  const ownerCol = ws.getColumn(2);
  if (ownerCol) ownerCol.width = 20;

  ws.views = [{ state: 'frozen', ySplit: 1 }];

  if (evidence.evaluated_records.length > 0) {
    ws.autoFilter = {
      from: { row: 1, column: 1 },
      to: { row: evidence.evaluated_records.length + 1, column: allCols.length },
    };
  }

  const summaryRow = evidence.evaluated_records.length + 3;
  ws.getCell(summaryRow, 1).value = 'SUMMARY';
  ws.getCell(summaryRow, 1).font = { bold: true, size: 11 };

  ws.getCell(summaryRow + 1, 1).value = 'Critical:';
  ws.getCell(summaryRow + 1, 2).value = evidence.evaluated_records.filter(r => r.severity === 'critical').length;
  ws.getCell(summaryRow + 2, 1).value = 'Warning:';
  ws.getCell(summaryRow + 2, 2).value = evidence.evaluated_records.filter(r => r.severity === 'warning').length;
  ws.getCell(summaryRow + 3, 1).value = 'Healthy:';
  ws.getCell(summaryRow + 3, 2).value = evidence.evaluated_records.filter(r => r.severity === 'healthy').length;
  ws.getCell(summaryRow + 4, 1).value = 'Total:';
  ws.getCell(summaryRow + 4, 1).font = { bold: true };
  ws.getCell(summaryRow + 4, 2).value = evidence.evaluated_records.length;
  ws.getCell(summaryRow + 4, 2).font = { bold: true };

  if (evidence.claims.length > 0) {
    const claimsRow = summaryRow + 6;
    ws.getCell(claimsRow, 1).value = 'CLAIMS';
    ws.getCell(claimsRow, 1).font = { bold: true, size: 11 };

    evidence.claims.forEach((claim, i) => {
      const r = claimsRow + 1 + i;
      const emoji = claim.severity === 'critical' ? 'üî¥' : claim.severity === 'warning' ? 'üü°' : '‚ÑπÔ∏è';
      ws.getCell(r, 1).value = `${emoji} ${claim.claim_text}`;
      ws.getCell(r, 2).value = `${claim.entity_ids.length} ${claim.entity_type}s`;
      ws.getCell(r, 3).value = claim.threshold_applied || '';
    });
  }
}

function mergeDataSources(allEvidence: SkillEvidence[]): DataSourceContribution[] {
  const merged = new Map<string, DataSourceContribution>();

  for (const ev of allEvidence) {
    for (const ds of ev.data_sources) {
      const existing = merged.get(ds.source);
      if (!existing || ds.connected) {
        merged.set(ds.source, ds);
      }
    }
  }

  return Array.from(merged.values());
}

function mergeParameters(allEvidence: SkillEvidence[]): SkillParameter[] {
  const merged = new Map<string, SkillParameter>();

  for (const ev of allEvidence) {
    for (const p of ev.parameters) {
      if (!merged.has(p.name)) {
        merged.set(p.name, p);
      }
    }
  }

  return Array.from(merged.values());
}
