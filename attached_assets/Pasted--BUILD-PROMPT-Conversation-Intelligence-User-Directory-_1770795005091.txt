# BUILD PROMPT: Conversation Intelligence — User Directory & Filtered Sync

## Context

Paste this into Replit. This refactors the Gong and Fireflies connectors 
to follow a two-step connect flow: fetch user directory → user selects 
which reps to track → sync ONLY those users' calls. This prevents the 
platform from drowning in irrelevant conversations (engineering standups, 
HR 1:1s, all-hands) and keeps the data focused on pipeline-relevant calls.

This pattern applies to ALL conversation intelligence connectors, not just 
these two. Any future connector (Zoom, Chorus, etc.) should follow the 
same flow.

---

## PROMPT

```
Read REPLIT_CONTEXT.md and SYNC_AUDIT_REPORT.md if they exist.

Refactor Gong and Fireflies connectors to support a two-step connect flow:
1. Connect credentials → test → fetch user directory
2. User selects which reps to track → save selections → sync only their calls

This is a BREAKING CHANGE to the current sync behavior. Currently both 
connectors pull ALL calls. After this change, they pull ONLY calls from 
tracked users. This is intentional — a pipeline intelligence platform 
should only ingest sales-relevant conversations.

--- DESIGN PRINCIPLES ---

1. User directory is fetched ONCE during connect, refreshed on demand.
2. Tracked user selection is stored in connector_configs.metadata.
3. Sync queries filter by tracked users at the API level (not post-fetch).
4. If no users are selected yet, sync should refuse to run and return 
   a clear error: "No tracked users configured. Select users first."
5. The tracked users list doubles as the "sales team roster" for skills 
   like Pipeline Coverage by Rep and Rep Scorecard.

--- DATABASE CHANGES ---

No new tables needed. Extend the connector_configs.metadata JSONB:

{
  // ... existing metadata ...
  "user_directory": {
    "fetched_at": "2026-02-10T12:00:00Z",
    "users": [
      {
        "source_id": "gong-user-123",
        "name": "Sarah Chen",
        "email": "sarah@company.com",
        "title": "Account Executive",
        "active": true
      }
    ]
  },
  "tracked_users": [
    {
      "source_id": "gong-user-123",
      "name": "Sarah Chen",
      "email": "sarah@company.com",
      "title": "Account Executive",
      "selected_at": "2026-02-10T12:05:00Z"
    }
  ]
}

--- GONG: USER DIRECTORY ---

The Gong client already has (or should have) a getUsers() method.
Verify it exists and returns the right shape.

Gong API: GET /v2/users
- Returns: { users: [{ id, emailAddress, firstName, lastName, title, 
  managerId, active, created }] }
- Cursor-based pagination (same as getCalls)
- Auth: same Basic auth as all Gong endpoints

Create or update: server/connectors/gong/client.ts

  async getUsers(): Promise<GongUser[]>
  - Fetch all users with pagination
  - Return normalized array: { source_id, name, email, title, active }
  - Filter to active users only (active === true)
  - Sort alphabetically by name

--- FIREFLIES: USER DIRECTORY ---

Fireflies has a GraphQL query for users.

Fireflies API: POST https://api.fireflies.ai/graphql

  query {
    users {
      user_id
      name
      email
      role          // admin, member, etc.
      is_admin
      integrations  // which tools they have connected
    }
  }

Note: Fireflies "users" are team members on the Fireflies account, 
which maps well to "people whose meetings are being recorded."

Create or update: server/connectors/fireflies/client.ts

  async getUsers(): Promise<FirefliesUser[]>
  - Execute the GraphQL query
  - Return normalized array: { source_id, name, email, role, active: true }
  - Sort alphabetically by name

--- SHARED: USER SELECTION STORAGE ---

Create: server/connectors/shared/tracked-users.ts

Export functions that work for ANY conversation connector:

  async function fetchAndStoreDirectory(
    workspaceId: string,
    connectorType: 'gong' | 'fireflies',
    users: NormalizedUser[]
  ): Promise<void>
  // Updates connector_configs.metadata.user_directory
  // Sets fetched_at to now()

  async function getDirectory(
    workspaceId: string,
    connectorType: 'gong' | 'fireflies'
  ): Promise<{ users: NormalizedUser[], fetchedAt: string } | null>
  // Reads from connector_configs.metadata.user_directory

  async function setTrackedUsers(
    workspaceId: string,
    connectorType: 'gong' | 'fireflies',
    userIds: string[]  // array of source_ids to track
  ): Promise<TrackedUser[]>
  // Validates userIds exist in the directory
  // Stores in connector_configs.metadata.tracked_users
  // Returns the full tracked user objects

  async function getTrackedUsers(
    workspaceId: string,
    connectorType: 'gong' | 'fireflies'
  ): Promise<TrackedUser[]>
  // Returns current tracked users list
  // Returns empty array if none selected

NormalizedUser shape:
  { source_id: string, name: string, email: string, title?: string, 
    role?: string, active: boolean }

TrackedUser shape:
  { source_id: string, name: string, email: string, title?: string,
    selected_at: string }

--- GONG: FILTERED SYNC ---

Update: server/connectors/gong/sync.ts (or wherever sync logic lives)

The Gong /v2/calls endpoint supports filtering by user:
- POST /v2/calls with body: { filter: { fromDateTime, toDateTime, workspaceId } }
- The filter also accepts: primaryUserId

However, the API only accepts ONE primaryUserId per request. To fetch 
calls for multiple tracked users, you need to make one paginated request 
per user.

Update the sync logic:

  async function syncGong(workspaceId: string, options?: { lookbackDays?: number }) {
    const trackedUsers = await getTrackedUsers(workspaceId, 'gong');
    
    if (trackedUsers.length === 0) {
      throw new Error('No tracked users configured for Gong. Select users before syncing.');
    }

    let totalSynced = 0;

    for (const user of trackedUsers) {
      // Gong getCalls accepts primaryUserId filter
      const calls = await gongClient.getCalls({
        fromDateTime: sinceDate,
        toDateTime: now,
        primaryUserId: user.source_id
      });
      
      // Transform and upsert as before
      const transformed = calls.map(c => transformGongCall(c, workspaceId));
      await upsertConversations(transformed);
      totalSynced += transformed.length;
    }

    return { totalSynced, trackedUsers: trackedUsers.length };
  }

IMPORTANT: Use gongFetch (throttled fetcher) for all these requests. 
With N tracked users, you're making N * pages requests instead of 1 * pages.
The rate limit (100/min) matters more now.

Consider running user syncs sequentially (not in parallel) to stay within 
rate limits. Log progress: "[Gong] Syncing user 3/8: Sarah Chen..."

--- FIREFLIES: FILTERED SYNC ---

Update: server/connectors/fireflies/sync.ts (or wherever sync logic lives)

Fireflies GraphQL supports filtering by organizer_email in the query:

  query {
    transcripts(
      limit: 50, 
      skip: 0,
      organizer_email: "sarah@company.com"
    ) {
      id title date duration organizer_email 
      summary { overview action_items keywords }
    }
  }

ALTERNATIVELY, Fireflies may support a participants filter. Check the 
API — if participants filtering exists, use that instead of organizer_email,
because a rep might be a participant but not the organizer (e.g., the 
customer scheduled the meeting).

Update the sync logic similarly to Gong:

  async function syncFireflies(workspaceId: string, options?: { lookbackDays?: number }) {
    const trackedUsers = await getTrackedUsers(workspaceId, 'fireflies');
    
    if (trackedUsers.length === 0) {
      throw new Error('No tracked users configured for Fireflies. Select users before syncing.');
    }

    let totalSynced = 0;
    const seenIds = new Set<string>();  // deduplicate across users

    for (const user of trackedUsers) {
      const meetings = await firefliesClient.getTranscripts({
        organizerEmail: user.email,
        fromDate: sinceDate,
        limit: 50
      });
      
      // Deduplicate: a meeting might appear for multiple tracked users
      // if they were both participants
      const newMeetings = meetings.filter(m => !seenIds.has(m.id));
      newMeetings.forEach(m => seenIds.add(m.id));
      
      const transformed = newMeetings.map(m => transformFirefliesCall(m, workspaceId));
      await upsertConversations(transformed);
      totalSynced += transformed.length;
    }

    return { totalSynced, trackedUsers: trackedUsers.length };
  }

IMPORTANT for Fireflies deduplication: Since conversations table has 
UNIQUE(workspace_id, source, source_id), the upsert handles DB-level 
deduplication. But the seenIds set prevents unnecessary transform + 
upsert work for meetings that appear in multiple users' results.

--- API ROUTES ---

Add these new endpoints for BOTH connectors. I'll show the Gong routes; 
duplicate the same pattern for Fireflies.

GET /api/workspaces/:id/connectors/gong/users
  - If directory exists and was fetched < 24 hours ago, return cached
  - Otherwise, fetch fresh from Gong API and store
  - Response: { 
      users: NormalizedUser[], 
      fetched_at: string,
      tracked_users: TrackedUser[]  // currently selected
    }

POST /api/workspaces/:id/connectors/gong/users/refresh
  - Force re-fetch directory from Gong API (new hires, departures)
  - Update connector_configs.metadata.user_directory
  - Return fresh user list

POST /api/workspaces/:id/connectors/gong/users/track
  - Body: { user_ids: string[] }  // source_ids to track
  - Validates all IDs exist in directory
  - Stores in connector_configs.metadata.tracked_users
  - Response: { tracked_users: TrackedUser[] }
  - NOTE: This REPLACES the full tracked list (not additive). 
    The UI sends the complete set of selected users each time.

DELETE /api/workspaces/:id/connectors/gong/users/track
  - Clears all tracked users
  - Sync will refuse to run until users are re-selected
  - Use case: workspace reconfiguration

GET /api/workspaces/:id/connectors/gong/users/track
  - Returns current tracked users
  - Response: { tracked_users: TrackedUser[], count: number }

Duplicate all of the above for Fireflies:
  GET    /api/workspaces/:id/connectors/fireflies/users
  POST   /api/workspaces/:id/connectors/fireflies/users/refresh
  POST   /api/workspaces/:id/connectors/fireflies/users/track
  DELETE /api/workspaces/:id/connectors/fireflies/users/track
  GET    /api/workspaces/:id/connectors/fireflies/users/track

--- UPDATE CONNECT FLOW ---

Update the connect endpoint for both connectors. Currently:
  POST /connect → test credentials → save config → done

New flow:
  POST /connect → test credentials → fetch user directory → save config → done

After a successful connect, the user_directory should already be populated 
in metadata. The client can immediately show the user selection screen 
without a separate API call.

Update the connect response to include the directory:

  Response: {
    status: 'connected',
    user_directory: {
      users: NormalizedUser[],
      fetched_at: string
    }
  }

--- SHARED ROSTER ENDPOINT ---

Create a unified endpoint that returns ALL tracked users across ALL 
conversation connectors for a workspace. This is what skills use to 
know "who is the sales team."

GET /api/workspaces/:id/sales-roster
  Response: {
    reps: [
      {
        name: "Sarah Chen",
        email: "sarah@company.com",
        title: "Account Executive",
        sources: ["gong", "fireflies"],  // tracked in both
        gong_user_id: "gong-123",
        fireflies_user_id: "ff-456"
      }
    ],
    total: number
  }

Implementation:
  1. Get tracked_users from Gong connector_config
  2. Get tracked_users from Fireflies connector_config
  3. Merge by email (same person may be tracked in both tools)
  4. Return unified roster

This roster is used by:
  - Pipeline Coverage by Rep (which reps have pipeline?)
  - Rep Scorecard (performance metrics per rep)
  - Activity alerts (which rep hasn't had a call in X days?)
  - The cross-entity linker (to distinguish internal vs external participants)

--- BACKWARD COMPATIBILITY ---

The sync endpoints should still work the same way:
  POST /api/workspaces/:id/connectors/gong/sync
  POST /api/workspaces/:id/connectors/fireflies/sync

The only behavioral change: they now filter by tracked users and refuse 
to run if no users are selected. The response should indicate this clearly:

  // Error case
  { error: "No tracked users configured", 
    action: "POST /api/workspaces/:id/connectors/gong/users/track to select users" }

  // Success case (updated response)
  { 
    synced: 45, 
    tracked_users: 5, 
    by_user: [
      { name: "Sarah Chen", calls: 12 },
      { name: "Mike Torres", calls: 8 },
      ...
    ],
    duration_ms: 3200 
  }

--- TESTING ---

After building, test with:

1. Connect Gong with credentials (should return user directory)
2. GET /api/workspaces/:id/connectors/gong/users — verify user list
3. POST /api/workspaces/:id/connectors/gong/users/track with 2-3 user IDs
4. POST /api/workspaces/:id/connectors/gong/sync?lookbackDays=7
   - Verify ONLY calls from tracked users are synced
   - Compare count to the previous "all calls" sync — should be lower
5. Check conversations table: all new records should have participants 
   that include at least one tracked user

6. Repeat steps 1-5 for Fireflies

7. GET /api/workspaces/:id/sales-roster — verify merged roster

8. Test edge cases:
   - Sync with 0 tracked users → should error clearly
   - Track a user with no calls in the lookback period → 0 synced, no error
   - Same person tracked in both Gong and Fireflies → appears once in roster
   - Refresh directory after connect → new users should appear

--- EDGE CASES ---

- Gong primaryUserId filter: If Gong's API changes or doesn't support 
  this filter, fall back to fetching all calls and filtering post-fetch 
  by checking if any participant matches a tracked user. Log a warning 
  if this fallback activates.

- Fireflies organizer_email: A tracked user might be a participant but 
  NOT the organizer. If Fireflies supports a participants filter, prefer 
  that. If not, document this limitation — some calls where the customer 
  scheduled the meeting will be missed. Consider also querying by 
  participants.email if the API supports it.

- Deactivated users in Gong: If a rep leaves the company, their Gong 
  user becomes inactive. The directory refresh should update the active 
  flag. The tracked_users list should NOT auto-remove deactivated users 
  (their historical calls are still valuable), but the UI can flag them.

- Large teams: Some orgs have 100+ Gong users. The directory fetch must 
  paginate properly. The user selection UI is a frontend concern (not 
  this prompt), but the API should support it with reasonable response sizes.

- Rate limits with multiple users: Syncing 10 tracked users means ~10x 
  the API calls vs. a single unfiltered query. For Gong (100 req/min), 
  that's fine for typical teams. For very large teams (50+ tracked users), 
  consider batching or adding a delay between users. Log total API calls 
  made during sync.
```