/**
 * Markdown Formatter for Skill Results
 *
 * Converts skill results into clean markdown format for reports/documents.
 */

import type { SkillResult, SkillDefinition } from '../types.js';

/**
 * Format skill result as markdown
 */
export function formatAsMarkdown(result: SkillResult, skill?: SkillDefinition): string {
  const lines: string[] = [];

  // Title
  if (skill) {
    lines.push(`# ${skill.name}`);
    lines.push('');
    lines.push(`**Category:** ${skill.category}`);
    lines.push(`**Version:** ${skill.version}`);
    lines.push('');
  } else {
    lines.push(`# Skill Result: ${result.skillId}`);
    lines.push('');
  }

  // Metadata
  lines.push('## Execution Summary');
  lines.push('');
  lines.push(`- **Status:** ${result.status}`);
  lines.push(`- **Run ID:** \`${result.runId}\``);
  lines.push(`- **Workspace:** ${result.workspaceId}`);
  lines.push(`- **Completed:** ${result.completedAt.toISOString()}`);
  lines.push(`- **Duration:** ${formatDuration(result.totalDuration_ms)}`);
  lines.push('');

  // Token usage
  lines.push('### Resource Usage');
  lines.push('');
  lines.push(`- **Claude Tokens:** ${result.totalTokenUsage.claude.toLocaleString()}`);
  lines.push(`- **DeepSeek Tokens:** ${result.totalTokenUsage.deepseek.toLocaleString()}`);
  lines.push(`- **Compute Calls:** ${result.totalTokenUsage.compute}`);
  lines.push('');

  // Steps
  if (result.steps.length > 0) {
    lines.push('### Execution Steps');
    lines.push('');
    lines.push('| Step ID | Tier | Status | Duration | Tokens |');
    lines.push('|---------|------|--------|----------|--------|');

    for (const step of result.steps) {
      lines.push(
        `| ${step.stepId} | ${step.tier} | ${step.status} | ${formatDuration(step.duration_ms)} | ${step.tokenUsage || 0} |`
      );
    }

    lines.push('');
  }

  // Errors
  if (result.errors && result.errors.length > 0) {
    lines.push('### Errors');
    lines.push('');
    for (const error of result.errors) {
      lines.push(`- **${error.step}:** ${error.error}`);
    }
    lines.push('');
  }

  // Output
  lines.push('---');
  lines.push('');
  lines.push('## Output');
  lines.push('');

  if (typeof result.output === 'string') {
    lines.push(result.output);
  } else if (result.output && typeof result.output === 'object') {
    if (Array.isArray(result.output)) {
      // Format array as markdown table if objects have consistent keys
      if (result.output.length > 0 && typeof result.output[0] === 'object') {
        const keys = Object.keys(result.output[0]);
        lines.push(`| ${keys.join(' | ')} |`);
        lines.push(`| ${keys.map(() => '---').join(' | ')} |`);

        for (const row of result.output) {
          const values = keys.map(key => formatCellValue(row[key]));
          lines.push(`| ${values.join(' | ')} |`);
        }
      } else {
        // Simple array
        for (const item of result.output) {
          lines.push(`- ${item}`);
        }
      }
    } else {
      // Format object as key-value pairs
      for (const [key, value] of Object.entries(result.output)) {
        lines.push(`**${key}:** ${formatValue(value)}`);
        lines.push('');
      }
    }
  } else {
    lines.push('*No output*');
  }

  lines.push('');
  lines.push('---');
  lines.push('');
  lines.push(`*Generated by Pandora Skill Framework*`);

  return lines.join('\n');
}

/**
 * Format pipeline hygiene report as markdown
 */
export function formatPipelineHygieneMarkdown(result: SkillResult): string {
  const lines: string[] = [];

  lines.push('# Pipeline Hygiene Report');
  lines.push('');
  lines.push(`**Generated:** ${result.completedAt.toISOString()}`);
  lines.push(`**Workspace:** ${result.workspaceId}`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Output
  const output = typeof result.output === 'string' ? result.output : JSON.stringify(result.output, null, 2);
  lines.push(output);

  lines.push('');
  lines.push('---');
  lines.push('');
  lines.push(`*Execution time: ${formatDuration(result.totalDuration_ms)} | Claude tokens: ${result.totalTokenUsage.claude}*`);

  return lines.join('\n');
}

/**
 * Format deal risk assessment as markdown table
 */
export function formatDealRiskMarkdown(result: SkillResult): string {
  const lines: string[] = [];

  lines.push('# Deal Risk Assessment');
  lines.push('');
  lines.push(`**Generated:** ${result.completedAt.toISOString()}`);
  lines.push(`**Workspace:** ${result.workspaceId}`);
  lines.push('');

  if (Array.isArray(result.output)) {
    lines.push('## Risk Assessment Results');
    lines.push('');
    lines.push('| Deal | Amount | Stage | Risk | Score | Factors | Action |');
    lines.push('|------|--------|-------|------|-------|---------|--------|');

    for (const deal of result.output) {
      const factors = Array.isArray(deal.factors) ? deal.factors.join('; ') : '';
      lines.push(
        `| ${deal.dealName} | $${deal.amount.toLocaleString()} | ${deal.currentStage} | ${deal.risk} | ${deal.riskScore} | ${factors} | ${deal.recommendedAction} |`
      );
    }

    lines.push('');

    // Summary stats
    const highRisk = result.output.filter((d: any) => d.risk === 'high').length;
    const mediumRisk = result.output.filter((d: any) => d.risk === 'medium').length;
    const lowRisk = result.output.filter((d: any) => d.risk === 'low').length;

    lines.push('### Summary');
    lines.push('');
    lines.push(`- **High Risk:** ${highRisk} deals`);
    lines.push(`- **Medium Risk:** ${mediumRisk} deals`);
    lines.push(`- **Low Risk:** ${lowRisk} deals`);
    lines.push('');
  } else {
    lines.push(typeof result.output === 'string' ? result.output : JSON.stringify(result.output, null, 2));
  }

  lines.push('---');
  lines.push('');
  lines.push(`*Execution time: ${formatDuration(result.totalDuration_ms)}*`);

  return lines.join('\n');
}

// ============================================================================
// Helper Functions
// ============================================================================

function formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  const seconds = Math.floor(ms / 1000);
  if (seconds < 60) return `${seconds}s`;
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds}s`;
}

function formatValue(value: any): string {
  if (value === null || value === undefined) return '*null*';
  if (typeof value === 'string') return value;
  if (typeof value === 'number') return value.toLocaleString();
  if (typeof value === 'boolean') return String(value);
  if (Array.isArray(value)) return value.join(', ');
  if (typeof value === 'object') return JSON.stringify(value, null, 2);
  return String(value);
}

function formatCellValue(value: any): string {
  if (value === null || value === undefined) return '';
  if (typeof value === 'string') return value;
  if (typeof value === 'number') return value.toLocaleString();
  if (typeof value === 'boolean') return String(value);
  if (Array.isArray(value)) return value.join(', ');
  if (typeof value === 'object') return JSON.stringify(value);
  return String(value);
}
